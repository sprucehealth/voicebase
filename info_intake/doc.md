# Purpose of document
This is intended to be a living documentation of the existing question-answer features, and how the pieces fit together.

# Goals 
The question-answer intake feature is built to:

1. Communicate a set of questions and answers of different types to a client
2. Package these questions into `layout` form to create a flow for the client to consume
3. Accept user input to the defined questions in a generic way
4. Communicate input to questions back to client

# Things to note
## How strings are stored
Strings are stored in localized form by leveraging an `app_text` table to define a new string via a tag, and then the localized form of each string is stored in `localized_text`.

## Immutability
Each layout, question or answer definition is considered immutable once created. Consequently each such component has to be versioned to be updated. This is for the simple reason that the meaning of a question or how the question was presented (via the layout) to the user cannot change.

Today, we support the versioning of layout definitions (as documented in https://github.com/SpruceHealth/backend/issues/90). What we don't yet support is granular versioning on a question and answer, other than essentially creating a completely new question if it needs to be updated.

# Piecing it together
Below is a description of each step in the system, and how things fit together.

## 1. Create new questions and answers
Questions and answers are stored in relational form in tables within a database. Each question and answer has a type (stored in `question_type` and `answer_type`) to define behavior pertaining to the question and 
the corresponding answer. 

New questions and their corresponding answers (if applicable) are created via migration files in the `mysql` package that are generated by hand, validated using a validation script, code-reviewed, and then applied to each environment. 

All questions and answers, regardless of which layout they belong to or for what purpose they are used are defined and stored in the `question` and `potential_answer` table. 

Questions and answers are unique identified by a human readable tag that is user-defined (`question_tag` and `potential_answer_tag`). Reason for the human readable tags is to make it possible to easily identify questions and answers in a given layout template, as well as determine a consistent way to identify questions across environments regardless of their database IDs.

The following attributes can be specified for a question:
- `qtext_app_text_id`: Question title
- `qtext_short_text_id`: Question summary which is used to provide a short description of the question
- `question_tag`: Question tag
- `qtype_id`: Question type referencing the `question_type` table.
- `parent_question_id`: Reference to the parent question when a question is a subquestion. Note that the reason for this reference is because this question is only fully defined when in the context of its parent.
- `required`: Whether or not a response is required for the question if shown to the user.
- `formatted_field_tags`: A list of comma separated tags to indicate content that is to be filled into the question. (*For the most part the questions thus far have not been dyanmic save a few places*)
-  `to_alert`: Whether or not to create a patient alert on the response to this question. *Note that how the alert is created depends on the type to the question*.
- `alert_app_text_id`: Text to use for the alert.

 *Note that the types of questions above are defined in the database*

The following attributes can be specified for a `potential_answer`:
- `question_id`: question the potential answer belongs to
- `answer_localized_text_id`: content of the answer
- `atype_id`: type of answer
- `potential_answer_tag`: uniquely identifiable tag
- `ordering`: ordering of the potential answer in the question
- `answer_summary_text_id`: summary of the answer that was selected
- `status`: whether or not answer is `ACTIVE` and should be used as part of the question
- `to_alert`: alert text to display if answer is selected

 *Note that the types of potential answers are defined in the database*

Note that due to the complexity and structure of photo sections, they are stored as a separate input type in the database and have the following structure. 

A `photo_slot` is an input type, just like `potential_answer` and can have the following attributes:
- `question_id`: question it belongs to, which is treated as a photo section question.
- `slot_name_app_text_id`: name of the slot 
- `slot_type_id`: reference to the slot type, which is essentially used to identify each slot (such as face right, face left, back, chest, other, etc)
- `required`: whether or not it is required to have a picture in the slot.
- `status`: whether or not input type is `ACTIVE`
- `placeholder_image_tag`: uniquely identifiable tag for the slot
- `ordering`: order in which the slot is to be present in the question

## 2. Creating the layout to define flow

A layout is a packaged way to communicate a list of questions and their flow to a client. We current define layouts for different purposes:

1. To define a visit intake.
2. To define a diagnosis intake for acne.
3. To define details intake for a diagnosis code.

 *Note that each of the layout definitions have additional fields that are defined for each structure, and while they are not called out here, they are definitely important and relevant to the complete definition of each structure. If we were to move this layout definition to a GUI, we'd have to figure out how best to move the definition of these additional structures to the GUI as well. Also note that each of the layouts contain display style information most relevant to the client which is parsed into JSON objects on the server and handed to the client, but not really used on the server side.*

### Visit intake layout
The structure for the visit intake layout is as follows:
```
{
  "sections" : [
       "screens" : [{
            "questions" : [{
               "condition" : {
                   ...
               },
               "subquestions_config" : {
                "screens" : [{
                    "questions" : [{
                         ...
                    }] 
                }],
               }, 
               "to_prefill" : true,
               ... 
             }]
       }]
   ],
   "transitions" : [{
      ...  
   }],
   ...
}
```

### Subquestion config
Subquestions are defined via a `subquestions_config` that can be present within a question definition to list an array of screens each of which contain a list of questions (note that the `screen` and `question` definitions are recursive in nature). 

### Condition object
This object defines the conditional that needs to be met for a question to be shown to the patient. It has an operation definition (`op`) that determines the remaining fields in the condition object. A point to note is that the condition object today is located in the layout definition as opposed to tied to the question in the database to give flexibility to a specific flow. 

### Cumulative medical history
Patients populate a cumulative medical history with every question they populate. As we introduce more conditions for patients, we may not need to ask input to certain questions again given that we already have answers to certain questions. Therefore, we needed a way in which to indicate that certain questions should be prefilled with previous answers to the same question (from another visit intake) if they existed. The `to_prefill` configuration on the question gives the flexibility to indicate if any question should be populated with this information. More information on the cumulative medical history can be found [here](https://docs.google.com/a/sprucehealth.com/document/d/1A-l5rwagelMq6tkXyHdV6s_vpkxq-hZDw5CidpxOzog/edit?usp=sharing).

### Layout validation and versioning
This has been explained in detail in this [github issue](https://github.com/SpruceHealth/backend/issues/90).


### Diagnosis intake layout
The structure for the diagnosis layout is as follows:
```
 {
    "sections" : [{
       "questions" : [{
          ...
       }]
    }],
    ...
 }
```


### Diagnosis details intake layout
The structure for the diagnosis layout is as follows:
```
{
  "questions" : [{
    ...
  }],
  ...
}
```


## 3. Storing user input 

User intake to the questions is stored in different tables pertaining to the use-case:

1. Patient intake is stored in the `info_intake` table
2. Patient photo intake is stored in the `photo_intake_section` table.
3. Doctor diagnosis intake is stored in the `diagnosis_intake` table.
4. Diagnosis details intake is stored in the `diagnosis_details_intake` table.

There is an `InfoIntake` interface which enables generalized storage of the answer intake for questions in each table and enables reuse of the intake feature-set. *Note that patient photo intake is stored in a non-generic way given the difference in nature of the input*

On a high level, if the intake can be defined by the `role` (such as `patient_id` or `doctor_id`) and a single `context` (such as `patient_visit_id` or `visit_diagnosis_item_id`) then it can leverage the generic way of storing and retrieving intake information.

The client has flexibility on whether to input answers for all questions at once or to submit input to a single question at a time. 

### Server side ordering of input 
Given the above described flexibility to the client to store answers to questions, its possible that the client submits two independent requests that represents an answer to the same question in the event that the user inputs an answer to a question and then goes back to change it. Therefore, it's possible for the server to receive input to the questions out of order if both requests happen over a slow connection or within quick succession.

To deal with this issue, the client can submit a `session_id` and a `counter` that is used server side to define a "client clock" and enforce ordering on the answers. If the session_id is the same, and the server receives input to a question with a lower counter value, then the answer is rejected. If the session id is different than the incoming session id for a given answer to a question, then the answer is accepted as it is considered a new session. With no session id and counter (which is the case with current clients) the last write wins.

## 4. Communicate input back to client
Below is how we handle rendering of input for each purpose:

### Populating visit intake with patient answers for patient
When the client makes a call to GET a `patient_visit`, we look up answers for questions in the layout from the database, and populate each `question` object with an `answers` array that indicates the patient answers. At this time, if the visit has not yet been submitted by the patient, we also obey the `to_prefill` flag on the question and populate any previous answers to the same question in the new visit.

Note that we don't yet have a "condensed" form of the layout to send to the patient to display, say, an overview of the visit or the patient input in review form. The client uses the status of the visit to determine how best to render the visit to the client (in open form so that patient walks through visit,  in review form with the ability to edit, or in read-only mode once visit has been submitted)

 *Note that while today we are traversing the layout to identify where to plug in the answers array for each question, we want to move to a model where the layout remains untouched, and a separate answers object is provided as a top level object in addition the layout. This also helps effectively communicate the concept of immutability with the layout.*

### Populating patient answers for doctor
The represent of patient answers to the doctor is decoupled from its input. This is intentionally done to provide flexible ways in which to show patient input to the doctor, as well as populate other relevant information in the visit that may be needed for the doctor. 

The doctor's review layout is defined as an array of views (and subviews) versus an array of questions (and subquestions). You can find the view definitions in the `info_intake` package in the `DVisitReviewTypeRegistry`. The view tree for the doctor is populated each time the doctor makes a call to get the visit for review. 

 *Note that while the patient input representation for the doctor is decoupled from the input, it is still linked to the intake layout in that the questions from the intake layout are keys to data that each view in the review layout is to be populated with. The intake and review layouts are thought of as pairs, as defined in the [layout versioning documentation](https://github.com/SpruceHealth/backend/issues/90).*

### Populating doctor answers for acne diagnosis
This is done similarly to how answers are populated for the patient_visit object for the patient app today, specifically because the answers are shown inline to the questions themselves as opposed to a different rendering as in the case of the visit review by the doctor. *Note that the same note regarding separating layout and answers objects applies though.*


### Populating doctor answers for diagnosis details in a visit
This leverages the concept described above of the top level `layout` and `answers` objects by transforming the answers from the database into a format understood by the client. Also, reason there is no view specific to the reviewing of the details is because the responses are shown inline in the question-answer format.

## Feature improvements
There is a [top-level asana task](https://app.asana.com/0/12387442313872/23093564131205) that contains a list of improvements that can be made to the feature. 
